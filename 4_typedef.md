# Синонимы
## Синонимы типов

Если имя какого-то пространства имен кажется нам слишком длинным, можно ввести для него короткий синоним.

В C++ typedef (сокращенно от «type definition», «определение типа») – это ключевое слово, которое создает псевдоним для существующего типа данных. Чтобы создать такой псевдоним, мы используем ключевое слово typedef, за которым следует существующий тип данных для псевдонима, за которым следует имя для псевдонима. Например:

```c++
typedef double distance_t; // определяем distance_t как псевдоним для типа double
```
По соглашению имена typedef объявляются с использованием суффикса "_t". Это помогает указать, что идентификатор представляет собой тип, а не переменную или функцию, а также помогает предотвратить конфликты имен с другими типами идентификаторов.

После определения имя typedef можно использовать везде, где требуется тип. Например, мы можем создать переменную с именем typedef в качестве типа:
```c++
distance_t milesToDestination{ 3.4 }; // определяет переменную типа double 
```

Обратите внимание, что typedef не определяет новый тип. Скорее, он просто создает новый идентификатор (псевдоним) для существующего типа. typedef можно использовать как замену везде, где можно использовать обычный тип.

## Область видимости

Поскольку область видимости является свойством идентификатора, идентификаторы typedef подчиняются тем же правилам области видимости, что и идентификаторы переменных: typedef, определенный внутри блока, имеет область видимости блока и может использоваться только внутри этого блока, тогда как typedef, определенный в глобальном пространстве имен, имеет область видимости файла и может использоваться до конца файла. В приведенном выше примере miles_t и speed_t можно использовать только в функции main().

Если вам нужно использовать один или несколько typedef в нескольких файлах, их можно определить в заголовочном файле и включить через #include в любые файлы исходного кода, которые должны использовать это определение (файл mytypes.h):

```c++
#ifndef MYTYPES
#define MYTYPES
 
    typedef long miles_t;
    typedef long speed_t;
 
#endif
```
Определения typedef, включенные таким образом, будут импортированы в глобальное пространство имен и, следовательно, будут иметь глобальную область видимости.

## Для чего нужны псевдонимы типов
### Размер типа данных
Одно из главных преимуществ псевдонимов типов заключается в том, что их можно использовать для скрытия деталей, специфичных для платформы. На некоторых платформах int составляет 2 байта, а на других – 4 байта. Таким образом, при написании кода, независимого от платформы, использование int для хранения более 2 байтов информации может быть потенциально опасным.

Поскольку char, short, int и long не указывают их размер, кроссплатформенные программы довольно часто используют псевдонимы типов для определения псевдонимов, которые включают размер типа в битах. Например, int8_t будет 8-разрядным целым числом со знаком, int16_t – 16-разрядным целым числом со знаком, а int32_t – 32-разрядным целым числом со знаком. Подобное использование псевдонимов типов помогает предотвратить ошибки и дает более четкое представление о том, какие предположения были сделаны относительно размера переменной.

Чтобы гарантировать, что каждый псевдоним типа преобразуется в тип нужного размера, псевдонимы типа такого рода обычно используются в сочетании с директивами препроцессора:

```c++
#ifdef INT_2_BYTES
using int8_t = char;
using int16_t = int;
using int32_t = long;
#else
using int8_t = char;
using int16_t = short;
using int32_t = int;
#endif
```
### Упрощение сложных типов

В продвинутом C++ типы могут быть сложными и длинными для ввода. Например, вы можете увидеть функцию и переменную, определенные следующим образом:
```c++
#include <string>  // для std::string
#include <vector>  // для std::vector
#include <utility> // для std::pair
 
bool hasDuplicates(std::vector<std::pair<std::string, int> > pairlist)
{
    // здесь какой-то код
    return false;
}
 
int main()
{
     std::vector<std::pair<std::string, int> > pairlist;
 
     return 0;
}
```

Ввод ```std::vector<std::pair<std::string, int> >``` везде, где вам нужно использовать этот тип, может оказаться громоздким. Гораздо проще использовать псевдоним типа:

```c++
#include <string>  // для std::string
#include <vector>  // для std::vector
#include <utility> // для std::pair
 
// делаем pairlist_t псевдонимом для этого сумасшедшего типа
using pairlist_t = std::vector<std::pair<std::string, int> >;
 
bool hasDuplicates(pairlist_t pairlist) // используем pairlist_t в параметре функции
{
    // здесь какой-то код
    return false;
}
 
int main()
{
     pairlist_t pairlist; // создаем экземпляр переменной pairlist_t
 
     return 0;
}
```
## Заключение
Хотя псевдонимы типов предлагают некоторые преимущества, они также вводят в ваш код еще один идентификатор, который необходимо понимать. Если это не компенсируется какими-либо преимуществами для удобочитаемости или понимания, тогда псевдоним типа приносит больше вреда, чем пользы.

Плохо используемый псевдоним типа может взять знакомый тип (например, std::string) и скрыть его за пользовательским именем, которое необходимо найти. В некоторых случаях скрытие информации о типе также может быть вредным для понимания того, как этот тип должен работать.

По этой причине псевдонимы типов следует использовать в первую очередь в тех случаях, когда есть явное преимущество для читабельности или поддерживаемости кода. Это в большей степени искусство, чем наука. Псевдонимы типов наиболее полезны, когда их можно использовать во многих местах кода, а не в меньшем количестве мест.

Источник: 

https://radioprog.ru/post/1131
